# 剑指Offer

### [49.丑数](../src/main/java/_剑指Offer/_49丑数.java)

- 三指针+动态规划 ★

### [48.最长不含重复字符的子字符串](../src/main/java/_剑指Offer/_48最长不含重复字符的子字符串.java)

- 滑动窗口+哈希表

- 动态规划

### [47.礼物的最大价值](../src/main/java/_剑指Offer/_47礼物的最大价值.java)

- 动态规划

### [41.数据流中的中位数](../src/main/java/_剑指Offer/_41数据流中的中位数.java)

- 优先队列

### [40.最小的k个数](../src/main/java/_剑指Offer/_40最小的k个数.java)

- 基于快排

### [39.数组中出现次数超过一半的数字](../src/main/java/_剑指Offer/_39数组中出现次数超过一半的数字.java)

- 摩尔投票法

### [37.序列化二叉树](../src/main/java/_剑指Offer/_37序列化二叉树.java)

- bfs

### [36.二叉搜索树与双向链表](../src/main/java/_剑指Offer/_36二叉搜索树与双向链表.java)

- dfs

### [34.二叉树中和为某一值的路径](../src/main/java/_剑指Offer/_34二叉树中和为某一值的路径.java)

- 回溯（注意添加path后 return前，remove最后一个元素）

### [33.二叉搜索树的后序遍历序列](../src/main/java/_剑指Offer/_33二叉搜索树的后序遍历序列.java)

- 关键点：二叉搜索树+后序遍历

### [32.2.从上到下打印二叉树2](../src/main/java/_剑指Offer/_32_2_从上到下打印二叉树2.java)

- dfs

- bfs

### [32.1.从上到下打印二叉树](../src/main/java/_剑指Offer/_32_1_从上到下打印二叉树.java)

- dfs

- bfs

### [31.栈的压入、弹出序列](../src/main/java/_剑指Offer/_31栈的压入_弹出序列.java)

- 用栈

### [29.顺时针打印矩阵](../src/main/java/_剑指Offer/_29顺时针打印矩阵.java)

- 模拟

### [28.对称的二叉树](../src/main/java/_剑指Offer/_28对称的二叉树.java)

- 递归

### [30.包含min函数的栈](../src/main/java/_剑指Offer/_30包含min函数的栈.java)

- TreeMap+Stack

- 双栈

### [26.树的子结构](../src/main/java/_剑指Offer/_26树的子结构.java)

- 递归

### [21.调整数组顺序使奇数位于偶数前面](../src/main/java/_剑指Offer/_21调整数组顺序使奇数位于偶数前面.java)

### [19.正则表达式匹配](../src/main/java/_剑指Offer/_19正则表达式匹配.java)

- 动态规划

### [16.数值的整数次方](../src/main/java/_剑指Offer/_16数值的整数次方.java)

- 乘法快速幂

### [18.删除链表的节点](../src/main/java/_剑指Offer/_18删除链表的节点.java)

### [17.打印从1到最大的n位数](../src/main/java/_剑指Offer/_17打印从1到最大的n位数.java)

### [11.旋转数组的最小数字](../src/main/java/_剑指Offer/_11旋转数组的最小数字.java)

- 二分

### [09.用两个栈实现队列](../src/main/java/_剑指Offer/_09用两个栈实现队列.java)

- 数据栈+辅助栈

- 插入栈+删除栈

### [06.从尾到头打印链表](../src/main/java/_剑指Offer/_06从尾到头打印链表.java)

### [05.替换空格](../src/main/java/_剑指Offer/_05替换空格.java)

- 遍历添加

- 正则表达式

### [03.数组中重复的数字](../src/main/java/_剑指Offer/_03数组中重复的数字.java)

- 原地置换

### [38.字符串的排列](../src/main/java/_剑指Offer/_38字符串的排列.java)

－ 回溯＋哈希

### [35.复杂链表的复制](../src/main/java/_剑指Offer/_35复杂链表的复制.java)

- 哈希表

### [27.二叉树的镜像](../src/main/java/_剑指Offer/_27二叉树的镜像.java)

- 递归

- 迭代（用栈）

### [10.2.青蛙跳台阶问题](../src/main/java/_剑指Offer/_10_2_青蛙跳台阶问题.java)

- 动态规划

### [32.Ⅲ.从上到下打印二叉树Ⅲ](../src/main/java/_剑指Offer/_32_3_从上到下打印二叉树3.java)

- 迭代

### [50.第一个只出现一次的字符](../src/main/java/_剑指Offer/_50第一个只出现一次的字符.java)

- 两次遍历+计数数组

### [64.求1到n的和](../src/main/java/_剑指Offer/_64求1到n的和.java)

- 递归+逻辑运算符 <<==>> for循环+if条件判断

### [58-2.左旋转字符串](../src/main/java/_剑指Offer/_58_2左旋转字符串.java)

### [63.股票的最大利润](../src/main/java/_剑指Offer/_63股票的最大利润.java)

- 一次遍历

- 动态规划

### [54.二叉搜索树的第k大节点](../src/main/java/_剑指Offer/_54二叉搜索树的第k大节点.java)

- 迭代

- 递归

### [14-1.剪绳子](../src/main/java/_剑指Offer/_14_1剪绳子.java)

- 数学推导

### [68-2.二叉树的最近公共祖先](../src/main/java/_剑指Offer/_68_2_二叉树的最近公共祖先.java)

- 哈希表

- 递归

### [45.把数组排成最小的数](../src/main/java/_剑指Offer/_45把数组排成最小的数.java)

- 自定义排序

### [42.连续子数组的最大和](../src/main/java/_剑指Offer/_42连续子数组的最大和.java)

- 一次遍历

- 分治法

### [62.圆圈中最后剩下的数字](../src/main/java/_剑指Offer/_62圆圈中最后剩下的数字.java)

- 约瑟夫环问题

- 模拟循环单链表

### [12.矩阵中的路径](../src/main/java/_剑指Offer/_12矩阵中的路径.java)

- 回溯

### [07.重建二叉树](../src/main/java/_剑指Offer/_07重建二叉树.java)

- 递归

### [53-2.0~n-1中缺失的数字](../src/main/java/_剑指Offer/_53_2_缺失的数字.java)

### [68-1.二叉搜索树的最近公共祖先](../src/main/java/_剑指Offer/_68_1_二叉搜索树的最近公共祖先.java)

- 哈希表

- 递归

### [14-Ⅱ.剪绳子2](../src/main/java/_剑指Offer/_14_2_剪绳子2.java)

- 数学推导

### [15.二进制中1的个数](../src/main/java/_剑指Offer/_15二进制中1的个数.java)

- 右移逐位计算

- 每次消去最右边的1：n&(n-1)

### [13.机器人的运动范围](../src/main/java/_剑指Offer/_13机器人的运动范围.java)

- 巧算数位和+dfs

- bfs

### [57-Ⅱ.和为s的连续正数序列](../src/main/java/_剑指Offer/_57_2和为s的连续正数序列.java)

- 暴力

- 滑动窗口

### [43.整数中1出现的次数](../src/main/java/_剑指Offer/_43整数中1出现的次数.java)

- 技巧型：从各位到最高位的1出现的次数的总和

### [52.两个链表的第一个公共节点](../src/main/java/_剑指Offer/_52两个链表的第一个公共节点.java)

- 哈希表

- 浪漫遍历

### [24.反转链表](../src/main/java/_剑指Offer/_24反转链表.java)

- 迭代：双指针

- 递归：
  - 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 newHead .
  - 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next指针指向当前节点。
  - 同时让当前结点的 next指针指向 NULL，从而实现从链表尾部开始的局部反转
  - 当递归函数全部出栈后，链表反转完成。